<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="2" skipped="0" tests="7" time="0.906" timestamp="2026-02-01T13:03:48.639596+01:00" hostname="Classic-Alfs"><testcase classname="tests.test_circuits" name="test_onion_build_and_relay_ad_binding" time="0.025" /><testcase classname="tests.test_coverage_probe" name="test_coverage_probe_basic" time="0.017" /><testcase classname="tests.test_handshake_mock" name="test_initiator_to_responder_s1_s2_flow" time="0.037" /><testcase classname="tests.test_handshake_mock" name="test_s2_bad_signature_logs" time="0.039"><failure message="assert False&#10; +  where False = any(&lt;generator object test_s2_bad_signature_logs.&lt;locals&gt;.&lt;genexpr&gt; at 0x7f0b903fe330&gt;)">tmp_path = PosixPath('/tmp/pytest-of-dvx3/pytest-5/test_s2_bad_signature_logs0')
caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7f0b8a0dea50&gt;

    @pytest.mark.asyncio
    async def test_s2_bad_signature_logs(tmp_path, caplog):
        cfg = tmp_path / "cfg2.yaml"
        cfg.write_text(
            """peer:\n  nickname: test2\nnetwork:\n  bind_host: 127.0.0.1\n  listen_port: 9002\n"""
        )
    
        node_a = PQVPNNode(str(cfg))
        node_b = PQVPNNode(str(cfg))
    
        t_a = DummyTransport()
        node_a.protocol = MockProtocol(t_a)
        node_a.transport = t_a
    
        t_b = DummyTransport()
        node_b.protocol = MockProtocol(t_b)
        node_b.transport = t_b
    
        pinfo = type("P", (), {})()
        pinfo.kyber_pk = node_b.kyber_pk
        # Use brainpoolP512r1 public key
        if hasattr(node_b, "brainpoolP512r1_pk") and hasattr(
            node_b.brainpoolP512r1_pk, "public_bytes"
        ):
            try:
                pinfo.brainpoolP512r1_pk = node_b.brainpoolP512r1_pk.public_bytes(
                    encoding=node_b.brainpoolP512r1_pk.public_bytes.__self__.encoding,
                    format=node_b.brainpoolP512r1_pk.public_bytes.__self__.format,
                )
            except Exception:
                pinfo.brainpoolP512r1_pk = b""
        else:
            pinfo.brainpoolP512r1_pk = b""
        pinfo.ed25519_pk = node_b.ed25519_pk
        pinfo.mldsa_pk = node_b.mldsa_pk
        pinfo.nickname = "peerb"
    
        addr = ("127.0.0.1", 9998)
    
        node_a.initiate_handshake(pinfo, addr)
        frame, dest = t_a.sent[-1]
        payload = frame[16:]
    
        # Make node_b handle S1 but tamper S2 signature before node_a handles it.
        await node_b.handle_s1(payload, addr)
        # tamper node_b's last sent S2
        frame2, dest2 = t_b.sent[-1]
        payload2 = frame2[16:]
        try:
            j = json.loads(payload2)
            j["mldsa_sig"] = "00" * 64  # invalid signature
            bad_payload = json.dumps(j, separators=(",", ":"), sort_keys=True).encode()
            await node_a.handle_s2(bad_payload, addr)
        except Exception:
            pass
    
        # Expect a warning logged about S2 signature verification (accept several variants)
&gt;       assert any(
            ("S2 signature verification failed" in rec.message)
            or ("S2 signature policy" in rec.message)
            or ("hybrid verification failed" in rec.message)
            for rec in caplog.records
        )
E       assert False
E        +  where False = any(&lt;generator object test_s2_bad_signature_logs.&lt;locals&gt;.&lt;genexpr&gt; at 0x7f0b903fe330&gt;)

tests/test_handshake_mock.py:214: AssertionError</failure></testcase><testcase classname="tests.test_parse_peers" name="test_parse_simple" time="0.001" /><testcase classname="tests.test_parse_peers" name="test_parse_json_line" time="0.000" /><testcase classname="tests.test_s1_s2_flow" name="test_s1_s2_handshake_flow" time="0.535"><failure message="AssertionError: nodeA has no established session&#10;assert False&#10; +  where False = any(&lt;generator object test_s1_s2_handshake_flow.&lt;locals&gt;._inner.&lt;locals&gt;.&lt;genexpr&gt; at 0x7f0b89bdd700&gt;)">tmp_path = PosixPath('/tmp/pytest-of-dvx3/pytest-5/test_s1_s2_handshake_flow0')
monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f0b8a0d70b0&gt;

    def test_s1_s2_handshake_flow(tmp_path, monkeypatch):
        """Synchronous pytest wrapper that runs the async handshake test body via asyncio.run.
    
        This avoids requiring the pytest-asyncio plugin in the test environment.
        """
    
        async def _inner():
            # Patch main's PQ functions to fakes
            monkeypatch.setattr(main, "pq_kem_encaps", fake_pq_kem_encaps)
            monkeypatch.setattr(main, "pq_kem_decaps", fake_pq_kem_decaps)
            monkeypatch.setattr(main, "pq_sig_keygen", fake_pq_sig_keygen)
            monkeypatch.setattr(main, "pq_sig_sign", fake_pq_sig_sign)
            monkeypatch.setattr(main, "pq_sig_verify_debug", fake_pq_sig_verify_debug)
            # Prefer patching pq_sig_verify; if pq_sig_verify_debug doesn't exist allow creation
            monkeypatch.setattr(main, "pq_sig_verify", fake_pq_sig_verify_debug)
            monkeypatch.setattr(main, "pq_sig_verify_debug", fake_pq_sig_verify_debug, raising=False)
    
            # Ensure hybrid enforcement is satisfied (we fake OQSPY availability)
            monkeypatch.setattr(main, "OQSPY_AVAILABLE", True)
            monkeypatch.setattr(main, "OQSPY_KEMALG", "Kyber1024")
            monkeypatch.setattr(main, "OQSPY_SIGALG", "ML-FAKE-TEST")
    
            # Create minimal config files for two nodes
            cfg_a = tmp_path / "a.yaml"
            cfg_b = tmp_path / "b.yaml"
            cfg_a.write_text(
                """peer:\n  nickname: nodeA\nnetwork:\n  bind_host: 127.0.0.1\n  listen_port: 9005\n"""
            )
            cfg_b.write_text(
                """peer:\n  nickname: nodeB\nnetwork:\n  bind_host: 127.0.0.1\n  listen_port: 9006\n"""
            )
    
            # Instantiate nodes
            nodeA = PQVPNNode(str(cfg_a))
            nodeB = PQVPNNode(str(cfg_b))
    
            # Wire fake bidirectional transports using FakeTransport
            tA = FakeTransport(nodeA, nodeB)
            tB = FakeTransport(nodeB, nodeA)
    
            protoA = SimpleNamespace(transport=tA)
            protoB = SimpleNamespace(transport=tB)
    
            nodeA.protocol = protoA
            nodeB.protocol = protoB
    
            # Create PeerInfo representing nodeB for nodeA to initiate handshake
            bpb = None
            try:
                bpb = nodeB.brainpoolP512r1_pk.public_bytes(
                    encoding=main.serialization.Encoding.X962,
                    format=main.serialization.PublicFormat.UncompressedPoint,
                )
            except Exception:
                # fallback to empty bytes
                bpb = b""
    
            pinfoB = main.PeerInfo(
                peer_id=nodeB.my_id or (hashlib.sha256(b"nodeB").digest()),
                nickname=nodeB.nickname,
                address=(nodeB.host, nodeB.port),
                ed25519_pk=nodeB.ed25519_pk,
                brainpoolP512r1_pk=bpb,
                kyber_pk=nodeB.kyber_pk,
                mldsa_pk=nodeB.mldsa_pk,
            )
    
            # Initiate handshake from A to B
            print(
                f"[TEST-DEBUG] nodeA.protocol present? {hasattr(nodeA, 'protocol')} proto={getattr(nodeA, 'protocol', None)} proto.transport={getattr(getattr(nodeA, 'protocol', None), 'transport', None)}"
            )
            nodeA.initiate_handshake(pinfoB, (nodeB.host, nodeB.port))
    
            # Allow some time for async datagram handling and handshake reply
            await asyncio.sleep(0.5)
    
            # Check that both nodes have established sessions
            assert any(
                s.state == main.SESSION_STATE_ESTABLISHED for s in nodeA.sessions.values()
            ), "nodeA has no established session"
            assert any(
                s.state == main.SESSION_STATE_ESTABLISHED for s in nodeB.sessions.values()
            ), "nodeB has no established session"
    
            # Find session pairs and verify peer ids
            sessA = next(
                (
                    s
                    for s in nodeA.sessions.values()
                    if s.remote_addr and s.remote_addr[1] == nodeB.port
                ),
                None,
            )
            sessB = next(
                (
                    s
                    for s in nodeB.sessions.values()
                    if s.remote_addr and s.remote_addr[1] == nodeA.port
                ),
                None,
            )
    
            assert sessA is not None and sessB is not None
            # peer_ids should be reciprocally present
            assert sessA.peer_id == (nodeB.my_id or sessA.peer_id)
            assert sessB.peer_id == (nodeA.my_id or sessB.peer_id)
    
            # Clean up: nothing to close for fake transports
    
        # Execute async test body
&gt;       asyncio.run(_inner())

tests/test_s1_s2_flow.py:243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.14/asyncio/runners.py:204: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
/usr/lib/python3.14/asyncio/runners.py:127: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.14/asyncio/base_events.py:719: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def _inner():
        # Patch main's PQ functions to fakes
        monkeypatch.setattr(main, "pq_kem_encaps", fake_pq_kem_encaps)
        monkeypatch.setattr(main, "pq_kem_decaps", fake_pq_kem_decaps)
        monkeypatch.setattr(main, "pq_sig_keygen", fake_pq_sig_keygen)
        monkeypatch.setattr(main, "pq_sig_sign", fake_pq_sig_sign)
        monkeypatch.setattr(main, "pq_sig_verify_debug", fake_pq_sig_verify_debug)
        # Prefer patching pq_sig_verify; if pq_sig_verify_debug doesn't exist allow creation
        monkeypatch.setattr(main, "pq_sig_verify", fake_pq_sig_verify_debug)
        monkeypatch.setattr(main, "pq_sig_verify_debug", fake_pq_sig_verify_debug, raising=False)
    
        # Ensure hybrid enforcement is satisfied (we fake OQSPY availability)
        monkeypatch.setattr(main, "OQSPY_AVAILABLE", True)
        monkeypatch.setattr(main, "OQSPY_KEMALG", "Kyber1024")
        monkeypatch.setattr(main, "OQSPY_SIGALG", "ML-FAKE-TEST")
    
        # Create minimal config files for two nodes
        cfg_a = tmp_path / "a.yaml"
        cfg_b = tmp_path / "b.yaml"
        cfg_a.write_text(
            """peer:\n  nickname: nodeA\nnetwork:\n  bind_host: 127.0.0.1\n  listen_port: 9005\n"""
        )
        cfg_b.write_text(
            """peer:\n  nickname: nodeB\nnetwork:\n  bind_host: 127.0.0.1\n  listen_port: 9006\n"""
        )
    
        # Instantiate nodes
        nodeA = PQVPNNode(str(cfg_a))
        nodeB = PQVPNNode(str(cfg_b))
    
        # Wire fake bidirectional transports using FakeTransport
        tA = FakeTransport(nodeA, nodeB)
        tB = FakeTransport(nodeB, nodeA)
    
        protoA = SimpleNamespace(transport=tA)
        protoB = SimpleNamespace(transport=tB)
    
        nodeA.protocol = protoA
        nodeB.protocol = protoB
    
        # Create PeerInfo representing nodeB for nodeA to initiate handshake
        bpb = None
        try:
            bpb = nodeB.brainpoolP512r1_pk.public_bytes(
                encoding=main.serialization.Encoding.X962,
                format=main.serialization.PublicFormat.UncompressedPoint,
            )
        except Exception:
            # fallback to empty bytes
            bpb = b""
    
        pinfoB = main.PeerInfo(
            peer_id=nodeB.my_id or (hashlib.sha256(b"nodeB").digest()),
            nickname=nodeB.nickname,
            address=(nodeB.host, nodeB.port),
            ed25519_pk=nodeB.ed25519_pk,
            brainpoolP512r1_pk=bpb,
            kyber_pk=nodeB.kyber_pk,
            mldsa_pk=nodeB.mldsa_pk,
        )
    
        # Initiate handshake from A to B
        print(
            f"[TEST-DEBUG] nodeA.protocol present? {hasattr(nodeA, 'protocol')} proto={getattr(nodeA, 'protocol', None)} proto.transport={getattr(getattr(nodeA, 'protocol', None), 'transport', None)}"
        )
        nodeA.initiate_handshake(pinfoB, (nodeB.host, nodeB.port))
    
        # Allow some time for async datagram handling and handshake reply
        await asyncio.sleep(0.5)
    
        # Check that both nodes have established sessions
&gt;       assert any(
            s.state == main.SESSION_STATE_ESTABLISHED for s in nodeA.sessions.values()
        ), "nodeA has no established session"
E       AssertionError: nodeA has no established session
E       assert False
E        +  where False = any(&lt;generator object test_s1_s2_handshake_flow.&lt;locals&gt;._inner.&lt;locals&gt;.&lt;genexpr&gt; at 0x7f0b89bdd700&gt;)

tests/test_s1_s2_flow.py:210: AssertionError</failure></testcase></testsuite></testsuites>